const std = @import("std");

const CEmuCore = @import("../cemucore.zig");

const Uop = enum {
    unimplemented,
    fetch_byte,
    add_r_1,
    dispatch_base,
    add_pc_1,
    halt,
    read_b,
    read_c,
    read_d,
    read_e,
    read_h,
    read_l,
    read_a,
    write_b,
    write_c,
    write_d,
    write_e,
    write_h,
    write_l,
    write_a,
    load_bc,
    load_de,
    load_hl,
    store_bc,
    store_de,
    store_hl,
};

const base = [_][]const Uop{
    &[_]Uop{.add_pc_1},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .fetch_byte, .add_pc_1, .write_b },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .fetch_byte, .add_pc_1, .write_c },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .fetch_byte, .add_pc_1, .write_d },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .fetch_byte, .add_pc_1, .write_e },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .fetch_byte, .add_pc_1, .write_h },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .fetch_byte, .add_pc_1, .write_l },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .fetch_byte, .add_pc_1, .write_a },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},

    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_c, .write_b },
    &[_]Uop{ .add_pc_1, .read_d, .write_b },
    &[_]Uop{ .add_pc_1, .read_e, .write_b },
    &[_]Uop{ .add_pc_1, .read_h, .write_b },
    &[_]Uop{ .add_pc_1, .read_l, .write_b },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_a, .write_b },
    &[_]Uop{ .add_pc_1, .read_b, .write_c },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_d, .write_c },
    &[_]Uop{ .add_pc_1, .read_e, .write_c },
    &[_]Uop{ .add_pc_1, .read_h, .write_c },
    &[_]Uop{ .add_pc_1, .read_l, .write_c },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_a, .write_c },
    &[_]Uop{ .add_pc_1, .read_b, .write_d },
    &[_]Uop{ .add_pc_1, .read_c, .write_d },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_e, .write_d },
    &[_]Uop{ .add_pc_1, .read_h, .write_d },
    &[_]Uop{ .add_pc_1, .read_l, .write_d },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_a, .write_d },
    &[_]Uop{ .add_pc_1, .read_b, .write_e },
    &[_]Uop{ .add_pc_1, .read_c, .write_e },
    &[_]Uop{ .add_pc_1, .read_d, .write_e },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_h, .write_e },
    &[_]Uop{ .add_pc_1, .read_l, .write_e },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_a, .write_e },
    &[_]Uop{ .add_pc_1, .read_b, .write_h },
    &[_]Uop{ .add_pc_1, .read_c, .write_h },
    &[_]Uop{ .add_pc_1, .read_d, .write_h },
    &[_]Uop{ .add_pc_1, .read_e, .write_h },
    &[_]Uop{.add_pc_1},
    &[_]Uop{ .add_pc_1, .read_l, .write_h },
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_a, .write_h },
    &[_]Uop{ .add_pc_1, .read_b, .write_l },
    &[_]Uop{ .add_pc_1, .read_c, .write_l },
    &[_]Uop{ .add_pc_1, .read_d, .write_l },
    &[_]Uop{ .add_pc_1, .read_e, .write_l },
    &[_]Uop{ .add_pc_1, .read_h, .write_l },
    &[_]Uop{.add_pc_1},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_a, .write_l },
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.halt},
    &[_]Uop{.unimplemented},
    &[_]Uop{ .add_pc_1, .read_b, .write_a },
    &[_]Uop{ .add_pc_1, .read_c, .write_a },
    &[_]Uop{ .add_pc_1, .read_d, .write_a },
    &[_]Uop{ .add_pc_1, .read_e, .write_a },
    &[_]Uop{ .add_pc_1, .read_h, .write_a },
    &[_]Uop{ .add_pc_1, .read_l, .write_a },
    &[_]Uop{.unimplemented},
    &[_]Uop{.add_pc_1},

    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},

    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
    &[_]Uop{.unimplemented},
};

pub fn decode(impl: anytype) void {
    dispatchAll(impl, &[_]Uop{ .add_r_1, .fetch_byte, .dispatch_base });
}

fn dispatcherFor(comptime table: *const [1 << 8][]const Uop) fn (anytype, comptime u8) void {
    return struct {
        fn dispatcher(impl: anytype, comptime opcode: u8) void {
            dispatchAll(impl, table[opcode]);
        }
    }.dispatcher;
}

fn dispatchAll(impl: anytype, comptime uops: []const Uop) void {
    inline for (uops) |uop| dispatch(impl, uop);
}

fn dispatch(impl: anytype, comptime uop: Uop) void {
    switch (uop) {
        .unimplemented => std.debug.todo(@tagName(uop) ++ " opcode"),
        .fetch_byte => impl.fetchByte(),
        .add_r_1 => impl.addR(1),
        .dispatch_base => impl.dispatch(dispatcherFor(&base)),
        .add_pc_1 => impl.addPC(1),
        .halt => impl.halt(),
        .read_b => impl.readRegister(.b),
        .read_c => impl.readRegister(.c),
        .read_d => impl.readRegister(.d),
        .read_e => impl.readRegister(.e),
        .read_h => impl.readRegister(.h),
        .read_l => impl.readRegister(.l),
        .read_a => impl.readRegister(.a),
        .write_b => impl.writeRegister(.b),
        .write_c => impl.writeRegister(.c),
        .write_d => impl.writeRegister(.d),
        .write_e => impl.writeRegister(.e),
        .write_h => impl.writeRegister(.h),
        .write_l => impl.writeRegister(.l),
        .write_a => impl.writeRegister(.a),
        .load_bc => impl.loadMemory(.ubc),
        .load_de => impl.loadMemory(.ude),
        .load_hl => impl.loadMemory(.uhl),
        .store_bc => impl.storeMemory(.ubc),
        .store_de => impl.storeMemory(.ude),
        .store_hl => impl.storeMemory(.uhl),
    }
}
